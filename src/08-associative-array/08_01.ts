export const usersObj = {
    '0': 'Dimych',
    '1': 'Natasha',
    '2': 'Valery',
    '3': 'Katya',
}
export const usersArray = [
    {id: 12345522, name: 'Dimych'},
    {id: 124908, name: 'Natasha'},
    {id: 103, name: 'Valery'},
    {id: 12341234, name: 'Katya'}
]
const user1 = {
    id: 100500,
    name: 'Igor'
}
usersArray.find(u => u.id === 12345522);
// доставание объекта из обычного массива, путем итерации по нему, сложность O(n), чем больше элементов
//в массиве, тем сложнее операция

const usersArrayCopy = [...usersArray, user1]; //Добавление нового пользователя
//в исходный массив иммутабельно. Но что если юзер уже лежит там? Нужно фильтровать старый массив
//чтобы убрать юзера старого и добавить нового, сложность алгоритма O(n).

const filteredUsersArray = usersArray.filter(u => u.id !== user1.id); //Снова итерация по всему массиву для удаления элемента из массива, сложность алгоритма O(n)

//Если нам нужно апдейтнуть свойство у определенного юзера, то снова нужно пробегаться мапом,
// сложность алгоритма O(n)

type UserType = {
    [key: string]: { id: number, name: string }
}
const users: UserType = {
    '12345522': {id: 12345522, name: 'Dimych'},
    '124908': {id: 124908, name: 'Natasha'},
    '103': {id: 103, name: 'Valery'},
    '12341234': {id: 12341234, name: 'Katya'},
}

// users[12345522] - доставание объекта из ассоциативного массива O(1) сложность одинаковая
//вне зависимости от кол-ва элементов

const user = {
    id: 100500,
    name: 'Igor'
}
users[user.id] = user // добавление нового юзера в ассоциативный массив. Если юзер с такой
// айдишкой уже был в массиве, то значение просто переприсвоится, сложность алгоритма: O(1)

delete users[user.id] //моментальное удаление юзера из массива, сложность алгоритма O(1)

users[103] = {id: 103, name: 'Oleg'}; //иммутабельный апдейт
users[12341234].name = 'Kostya'; //мутабельный апдейт

//Если нам нужно апдейтнуть свойство у определенного юзера, то мы обращаемся по айдишке и сходу моментально меняем его, сложность алгоритма O(1)